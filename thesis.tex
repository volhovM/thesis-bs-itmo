\documentclass[]{itmo-student-thesis}
% \documentclass[specification,annotation]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, требует пакета pscyr.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}

% Links to papers that are going to be translated to proper format:
% (1) https://bitcoin.org/bitcoin.pdf
% (2) http://vukolic.com/iNetSec_2015.pdf
% (3) https://iohk.io/research/papers/#9BKRHCSI
% (4) http://cs.umd.edu/~amiller/permacoin.pdf
% (5) https://github.com/input-output-hk/plutus-prototype/blob/master/docs/spec/Formal%20Specification%20of%20the%20Plutus%20Language%20-%20McAdams.pdf

\begin{filecontents}{bachelor-thesis.bib}
@inproceedings{ example-english,
    year        = {2015},
    booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
    author      = {Maxim Buzdalov and Anatoly Shalyto},
    title       = {Hard Test Generation for Augmenting Path Maximum Flow
                   Algorithms using Genetic Algorithms: Revisited},
    pages       = {2121-2128},
    langid      = {english}
}

@article{ example-russian,
    author      = {Максим Викторович Буздалов},
    title       = {Генерация тестов для олимпиадных задач по программированию
                   с использованием генетических алгоритмов},
    journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
    number      = {2(72)},
    year        = {2011},
    pages       = {72-77},
    langid      = {russian}
}

@article{ unrestricted-jump-evco,
    author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
    title       = {The Unrestricted Black-Box Complexity of Jump Functions},
    journal     = {Evolutionary Computation},
    year        = {2016},
    note        = {Accepted for publication},
    langid      = {english},
    keywords    = {index:wos, index:scopus, labauthor:buzdalov}
}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}

\studygroup{M3438}
\title{Тайм-трекинг пользовательских действий на распределенной блокчейн-сети}
\author{Волхов Михаил Александрович}{Волхов М.А.}
\supervisor{Штукенберг Дмитрий Григорьевич}{Штукенберг Д.Г.}{специалист}{тьютор кафедры КТ Университета ИТМО}
\publishyear{2017}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
% \startdate{01}{сентября}{2016}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
% \finishdate{31}{мая}{2017}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
% \defencedate{15}{июня}{2015}

% \addconsultant{}{канд. физ.-мат. наук, без звания}
\addconsultant{Йонн Мостовой}{без степени, без звания}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется разработать систему для тайм-трекинга пользовательских действий с помощью блокчейн-технологии. Алгоритм должен поддерживать многопользовательские действия. Должна быть разрабтана формализация социальных контрактов и система оценки пользовательских действий на основании данных тайм-трекинга. }

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Пояснительная записка должна описывать алгоритм достаточно хорошо, чтобы всем понравилось и никто не жаловался. TODO}

%%% Исходные материалы и пособия
\plannedsources{
  \begin{enumerate}
  \item Интернеты;
  \item Моар интернетов;
  \end{enumerate}
}

%%% Календарный план
\addstage{Ознакомление с имеющимися решениями в сфере тайм-трекинга}{02.2017}
\addstage{Ознакомление с практиками построения современных криптовалют}{02.2017}
\addstage{Реализация общего вида алгоритма}{03.2017}
\addstage{Написание пояснительной записки с проработанным формальным фреймворком}{04.2015}
\addstage{Доработка записки и доказательств}{05.2015}

%%% Цель исследования
\researchaim{Разработка тайм-трекинг системы с контрактами как надстройки над криптовалютой}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
  \item Соответствие алгоритма требованиям архитектуры (блокчейн).
  \item Гибкий интерфейс: возможность реализации мобильного клиента для использования с алгоритмом.
  \item Формализация контрактной системы должна покрывать минимум повторяющиеся контракты с фиксированным временем в период.
  \item Алгоритм должен быть спроектирован так, чтобы не нарушать гарантий безопасности базовой системы.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\advancedtechnologyusage{Была использована система компьютерной верстки \LaTeX, а в
рамках нее следующие пакеты, в порядке появления в стилевом файле: babel, csquotes,
geometry, amsmath, amssymb, amsthm,
amsfonts, amsextra, graphicx, xcolor, colortbl, tabu, caption, floatrow, algorithm,
algorithmicx, algpseudocode, enumitem, setspace, biblatex (а именно biber), lastpage,
totcount, longtable, listings, chngcntr, titlesec, titletoc, ifpdf.}

%%% Краткая характеристика полученных результатов
\researchsummary{Была разработана система Timecoin поверх криптовалюты Ouroboros, TODO}

%%% Гранты, полученные при выполнении работы
\researchfunding{Грантов при выполнении работы получено не было.}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{Тема работы не была упомянута в выступлениях и конференциях в каком-либо виде.}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

Решения, основанные на блокчейне, показывают возможность создания
распределенной сети, решающей конкретную проблему, одновременно не
требуя доверия к конкретным узлам сети и поддерживая стабильность
протокола. Блокчейн был применен в разных сферах проектирования
ПО. Особенно популярными стали решения в области криптовалют,
основанные на блокчейне, такие как Bitcoin [1], Ouroboros [3]. Также
существуют системы для распределенного хранения данных
(storj\footnote{Storj decentralized cloud storage
  \url{https://storj.io/storj.pdf}}, Permacoin[4]), голосования
(followmyvote\footnote{Follow my vote:
  \url{https://followmyvote.com/}}, bitcongress\footnote{BitCongress:
  \url{http://www.bitcongress.org/}}). Область применения широка и не
ограничивается приведенными примерами. Блокчейн -- это простое и
устойчивое решение для создания распределенной сети с большим
количеством узлов, что является ограничением BFT (byzantine fault
tolerant -- устойчивым к проблеме византийских генералов) алгоритмов
достижения консенсуса [2]. Блокчейн-решения хорошо масштабируются
горизонтально и предоставляют базу для алгоритмов, имеющих гарантии
безопасности относительно различных атак.

Программное обеспечение для организации рабочего процесса и
тайм-трекинга на первый взгляд полностью ортогонально продуктам,
основанным на блокчейне. Все рассматриваемые решения можно условно
поделить на две категории: органайзеры (google
calendar\footnote{Google calendar:
  \url{https://gsuite.google.com/learning-center/products/calendar/}},
remember the milk\footnote{Remember the milk: online to-do list and
  task management \url{https://www.rememberthemilk.com/tour/}}) и
тайм-трекеры (arbtt\footnote{Arbtt: completely automatic time tracker
  \url{https://arbtt.nomeata.de/#what}}, toggl\footnote{Toggl time
  tracker \& employee timesheet software
  \url{https://toggl.com/}}). Некоторые продукты совмещают в себе обе
функциональности: org-mode\footnote{Org-mode:
  \url{http://orgmode.org/}}, youtrack\footnote{ Youtrack:
  \url{https://www.jetbrains.com/youtrack/}}. Органайзеры оперируют в
терминах задач. Задачам можно присвоить различные временнЫе атрибуты,
вроде запланированного времени, чтобы не пропустить важную
встречу. Тайм-трекеры позволяют эффективно снимать статистику о том,
как пользователь тратит свое время. Анализ собранной статистики может
помочь найти проблемные места в организации жизнедеятельности
(например, выявлять и устранять прокрастинацию).

Однако, автору не известно ни одно решение, поддерживающее
мультипользовательский тайм-трекинг. Под этим термином подразумевается
возможность хранения не только информации о том, что группа
пользователей совместно участвовала в какой-то деятельности, но и
подтверждение этой информации от каждого участика. Эта идея
продолжается на мультипользовательские контракты. Если сервис имеет
достаточно знаний о том, какие группы пользователей должны тратить
время совместно на установленные задачи и в каком объеме, то оценка
таких соглашений может быть автоматизирована, если известны данные о
тайм-трекинге.

Блокчейн и криптовалюты предлагают прямое решение. Во-первых, идея
мультипользовательского тайм-трекинга близка к идее
мультипользовательских транзакций. Во-вторых, большинство криптовалют
реализуют в том или ином виде фреймворк для скриптинга, который
позволяет выполнять произвольные вычисления с данными на блокчейне,
что может быть эффективно использовано для распределения очков
рейтинга в рамках контракта. В-третьих, высокий рейтинг пользователей
свидетельствует о их компетентности в вопросе
договоренностей. Блокчейн представляет эффективный способ хранения
псевдо-публичной информации и дает возможности гибко настроить
механизм публикации таких данных.

Для большей наглядности того, как могут быть применена система с
поддержкой мультипользовательских контрактов и транзакций, приведем
два примера:

\begin{enumerate}
  \item Модифицированный семейный спор. Бессрочный контракт периодом в
    две недели предполагает, что на активность ``театр'' будет
    потрачено как минимум 3 часа в одной транзакции, а на активность
    ``футбол'' будет потрачено не менее четырех (в рамках
    периода). При этом контракт обязывает обоих партнеров участвовать
    в каждой из этих активностей. Прийдя на мероприятие, супруги (с
    помощью мобильного приложения) отмечают начало и тип действия, а
    по окончании каждый подтверждает эту информацию с помощью своего
    публичного ключа (опять-таки, через интерфейс мобильного
    приложения). По истечении недели умный контракт распределяет
    супругам очки рейтинга в зависимости от того, как были
    удовлетворены нужды каждого партнера. Ни один из участников не в
    силах самостоятельно подделать информацию о совместном
    времяпровождении. Поскольку партнеры пытаются максимизировать свой
    рейтинг, их стратегия должна быть построена так, чтобы избегать
    посещения мероприятий в одиночку. Любой из партнеров может
    провести псевдо-публичный аудит этой информации стороннему лицу,
    подтвердив свою способность следовать семейным
    договоренностям. Схема хорошо обобщается на полиаморические
    отношения.
  \item Фриланс биржа. Компания, которая хостит сайт для фрилансеров,
    разворачивает локальный мультипользовательский тайм-трекер для
    использования в связке с функционалом сайта. Заказчик и
    исполнитель, оформляя контракт через сайт, создают скрипт-контракт
    в блокчейне. Они договариются на 40 часов еженедельной работы в
    течение двух месяцев и на минимум два часовых митинга в течение
    каждой недели. Исполнитель отмечает свою рабочую деятельность с
    помощью интерфейса сайта и просит заказчика подтвердить транзакцию
    в конце дня, предоставляя ему сводку выполненных задач за
    день. Еженедельные митинги трекаются с обеих сторон. В случае
    невыполнения требований исполнитель теряет рейтинг, который
    привязан к его аккаунту.
\end{enumerate}

%% Начало содержательной части.
\chapter{Обзор предметной области}

\section{Децентрализованные платежные системы}

Биткоин -- первая распределенная платежная система, получившая
значительную популярность. Среди других подобных решений, биткоин
занимает 62\% всей рыночной капитализации\footnote{по данным
  \url{https://coinmarketcap.com/} на 28.04.2017}. Блокчейн-технология
для распределнного хранения состояния и вероятностный алгоритм PoW
(proof-of-work, дословно ``доказательство выполнения работы'') стали
идеальной комбинацией, которая и привела к широкому
распостранению. Существует много других решений в сфере криптовалют,
из которых значительная часть также используют блокчейн + PoW.

\subsection{Блокчейн (WIP)}

Блокчейн это очень простое решение для поддержки общего состояния
узлов в сети, обеспечивающее открытость (любой узел может
присоединиться), полную децентрализацию и отличное горизонтальное
масштабирование. Блокчейн/PoW решения обычно противопоставляются BFT
алгоритмам репликации состояния. Эта дуальность порождает
компромиссную модель, описанную в [2]: в частности, BFT алгоритмы
обеспечивают большую пропускную способность и производительность.

\subsection{Транзакции и UTXO}

Сравнение PoW и PoS. Нужно описать тут, потому что это не упоминается
в секции про Ouroboros.

\section{Ouroboros}

Ouroboros это первый протокол криптовалюты, основанный на схеме PoS и
имеющий доказанные гарантии безопасности относительно условий
стабильности цепи. Выбор этого протокола обоснован несколькими
ключевыми факторами. Во-первых, подход PoS превосходит PoW решения как
в защите от атак (TODO selfish mining, bribery attacks), так и в
экономии вычислительных ресурсов. Остальные подходы не являются
достаточно формальными и популярными одновременно и так или иначе
тратят избыток физического ресурса. Во-вторых, Ouroboros основан на
идее слоттинга -- разбиения времени на слоты одинаковой
длительности. Таким образом, блоки выпускаются в более-менее
фиксированный период времени. Это свойство не выполняется в PoW
решенях, где разница между выпущенными блоками вероятностна и основана
на текущей сложности выпуска блока -- переменная, которая в общем
случае меняется со временем. Ресурс BlockchainInfo предоставляет
возможность удостовериться, что реальное время выпуска блока в bitcoin
варьируется от 1 до более чем 30 минут.

\subsection{Общая модель протокола}

Эта подсекция описывает общую модель протокола Ouroboros.

\subsubsection{Слоттинг и параметры безопасности}

Протокол фиксирует следующие публично известные константы,
используемые для слоттинга: $startT, slotT, k, epochK$. $startT$ --
метка времени (в POSIX миллисекундах), означающая время начала работы
протокола. $slotT$ -- время одного слота в миллисекундах. $k$ это
константа безопасности, означающая количество последних неустойчивых
блоков в цепи. $epochK$ является множителем $k$, задающий эпоху. Для
удобства в дальнейшем введем еще одну переменную: $epochSlots = epochK
\times k$.

Слот -- это монотонно возрастающая функция от текущего времени
$currentT$, которая вычисляется как $getSlot(t) = (t - startT) /
slotT$, где все переменные имеют одну размерность (например,
миллисекунды). Длина слота $slotT$ должна быть больше ожидаемой
задержки на доставку среднего сообщения протокола.  Слот $j$
принадлежит эпохе $i$, если $i = \lfloor j / epochSlots \rfloor$.

Параметр безопасности $k$ определяет постоянство (persistence)
системы. Транзакция считается стабильной, если ее позиция в общей цепи
глубже, чем последние $k$ блоков.

\subsubsection{Свойства цепи транзакций}

Блокчейн Ouroboros'а спроектирован в манере близкой к большинству
имплементаций, в том числе к блокчейну биткоина. Он содержит в себе
список блоков, в котором каждый последующий (более новый) содержит в
себе хэш заголовка предыдущего, заголовок и тело. В отличии от
блокчейна биткоина, блоки Ouroboros'а делятся на два типа: главные
блоки и генезис блоки. Каждый главный блок имеет соответствующий
слот. Каждый (прошедший) слот имеет один соответствующий ему главный
блок, или не имеет вовсе.

Главные блоки несут основную функциональность транзакционного журнала
и схожи с блоками биткоина. Тело главного блока содержит список
транзакций, данные о SSC и другую относительно большую
информацию. Заголовок содержит следующие поля:

\begin{enumerate}
\item Доказательство данных тела: дататайп, содержащий информацию,
  необходимую для того, чтобы авторизовать тело блока. В частности,
  содержит дерево Меркла, построенное на списке транзакций.
\item Данные консенсуса: текущая эпоха и слот, сложность (высота
  текущего блока в общей цепи), публичный ключ лидера слота, подпись
  блока (заголовка, публичным ключом лидера слота).
\end{enumerate}

Генезис блок содержит информацию о слот лидерах. Лидер слота это
участник сети (имеющий достаточную долю средств с точки зрения
блокчейна), который единственно уполномочен выпустить блок в
конкретный слот. В течение каждой эпохи алгоритм, называющийся SSC
(shared seed calculation), собирает случайные данные для формирования
сида, который детерминированно определяет слот лидеров следующей
эпохи. Список слот лидеров и сид -- все, что находится в теле
генезисного блока. Заголовок схож с заголовком главного блока -- он
содержит в себе доказательство данных тела и эпоху. Генезис блоки
выпускаются участниками сети независимо и равны при условии того, что
участники видят один и тот же префикс блокчейна.

\subsubsection{SSC}

Ouroboros предлагает использовать вариант протокола конфиденциального
вычисления (multi-party computation, MPC) для вычисления равномерно
случайной строки, которая будет использована в процессе выбора
лидеров.

Коммитментом от случайной строки $r$ и сообщения $m$ является такое
сообщение $c = Com(r,m)$, что для спареной функции раскрытия $o =
Open(r,m)$ само $o$ является доказательством того, что $m$ --
сообщение внутри $c$. В то же время $c$ сам по себе не раскрывает
никакой информации о $m$.

Участвовать в протоколе SSC могут только те пользователи, которые
имеют достаточно средств (выше установленного порога) по состоянию на
конец предыдущей эпохи. Каждая эпоха делится на три фазы по: фаза
коммитментов ($2k$ слотов), фаза раскрытий ($4k$ слотов) и фаза
восстановления (последние $4k$ слотов). В первую фазу, которая длится
$2k$ блоков, участники SSC отсылают коммитменты. Во вторую фазу они
раскрывают свои коммитменты, отправляя раскрытия сделанных ранее
коммитментов. Третья фаза необходима для восстановления секрета при
условии, что какие-то раскрытия были потерянны. Для этого используется
дополнительный слой криптографии, обеспечивающий избыточность данных
(Verifiable secret sharing).

Все данные SSC хранятся в телах главных блоков.

\subsection{Система поощрений}

Система поощрений является набором правил, которые стимулируют
участников протокола принимать участие в выпуске блоков и SSC с
помощью присвоения им награды.

Для того, чтобы смотивировать участников принимать транзакции, каждому
слоту присваивается фиксированное количество эндорсеров. Задача
эндорсера состоит в том, чтобы собирать транзакции в сети. Лидер слота
получает подписанные данные от эндорсеров, объединяет их и кладет эти
данные в блок. Каждый участник сети может установить соответствие
между транзакциями и эндорсерами, от которых они были получены.

В систему также вводится понятие комиссии транзакции. Проверка
транзакции на валидность допускает ненулевую разницу между суммой
выходов и входов транзакции. Это значение и называется комиссией. Все
комиссии за эпоху $e$ суммируются, получая значение $S$. Протокол
предлагает равномерное распределение $S$ среди лидеров слота и
эндорсеров: участник $U$ может претендовать на долю $m * S / n$, где
$m$ это количество раз которое он был лидером или эндорсером за эпоху
$e$, а $n$ суммарное число лидеров и эндорсеров в эту эпоху. $U$
получает деньги, отправляя себе транзакцию с указанной суммой в эпоху
$e+1$.

Утверждается, что представленная стратегия распределения награды
соответствует приближенному равновесию по Нэшу, то есть любой участник
протокола, отклоняющийся от него, получает не более $1 + \epsilon$ той
награды, которую он бы точно получил, придерживаясь протокола.

\section{Улучшения и дополнительная функциональность}

Биткоин в текущей своей реализации поддерживает большое количество
дополнительных уровней протокола, не упомянутых в оригинальной
статье. Улучшения и модификации специфицируются в BIP (bitcoin
improvement proposals). Эта секция описывает некоторые из них.

\subsection{Скриптинг и P2SH}

Скриптинг или P2SH (pay-to-script-hash, дословно ``перевод на хэш
скрипта'') -- модификация криптовалюты, позволяющая пользователям
создавать адреса с гибкими, настраиваемыми условиями снятия денег. В
биткоине стандартизирована под
BIP16 \footnote{\url{https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki}}. Данная
часть опишет более общую структуру.

Протокол криптовалюты определяет поддерживаемый скриптовый язык. Он
может быть как тьюринг-полным (Plutus, [5]), так и неполным (биткоин
использует стековый язык, похожий на Форт). Пользователь создает
скрипт-валидатор, который принимает один аргумент произвольного типа и
возвращает, условно, булевое значение. Валидатор может быть
захеширован и использован как публичный адрес криптовалюты. Любой
пользователь может перевести средства на этот адрес. Для того, чтобы
перевести деньги с этого адреса, к доказательству транзакции должен
быть приложена пара из двух скриптов. Один из них -- валидатор, хэш
которого должен совпадать с адресом, с которого списываются
средства. Второй -- ридимер, генерирует входные данные для
валидатора. Чтобы проверить валидность траты средств, нужно
сгенерировать аргументы ридимером, передать их валидатору и
удостовериться, что последний вернул $true$.

Основная реализация протокола Ouroboros (Cardano
SL\footnote{https://github.com/input-output-hk/cardano-sl}) использует
скриптовый язык Plutus Ouroboros implementation (cardano-sl) uses
scripting language Plutus. Это функциональный тьюринг-полный язык со
строгой типизацией, схожий с Haskell. Скрипт-валидатор в Plutus имеет
типовую сигнатуру \lstinline|validator :: A -> Comp B|, где
\lstinline|Comp| это встроенный дататайп, изоморфный $Maybe$ с
точностью до инстанса класса монады. Он имеет два конструктора:
\lstinline|success :: B -> Comp B| и \lstinline|failure :: Comp B|.
Скрипт-ридимер в Plutus имеет тип \lstinline|Comp A|. Несложно
видеть, что поскольку $Comp$ является монадой, то проверка возможности
потратить инпут есть \lstinline|redeemer >>= validator|. Стоит
отметить, что несмотря на то, что возвращаемое значение валидатора --
это \lstinline|Comp a|, алгоритм валидации не проверяет значение
внутри конструктора, а лишь удостоверяется, что значение не является
\lstinline|failure|.

Приведем пример тривиального валидатора и ридимера.

\begin{lstlisting}[float=!h,caption={Пример пары валидатор/ридимер на Plutus}]
data Foo = { Foo | Bar }

validator : Foo -> Comp Unit {
    validator x = case x of {
        Foo  -> success MkUnit ;
        Bar  -> failure } }

redeemer : Comp Int {
    redeemer = success Foo }
\end{lstlisting}

Plutus имеет стандартную библиотеку, которая предоставляет базовые
типы данных и функции: обертки $Either$ и $Maybe$, списки и различные
придкаты. Также существует поддержка для добавления встроенных
функций. Встроенные функции могут использовать ресурсы узла сети. С
помощью них валидатор может, например, достать UTXO, относящееся к
какому-то конкретному блоку или периоду блокчейна. Фреймворк
достаточно гибок достаточно сложные операции валидации.

\section{Цветные монеты}

Цветные монеты (colored coins) это расширение криптовалюты,
позволяющее поддерживать разные типы сбережений. К значению ресурса
добавляется специальный тег, который наызвается цветом. Цветные
моменты были изначально стандартизированы и реализованы как настройка
над биткоином в стандарте
EPOBC\footnote{\url{https://github.com/chromaway/ngcccbase/wiki/EPOBC_simple}}
в 2012. В настоящий момент существуют еще несколько иных решений:
стандарт OAP \footnote{Open Assets Protocol
  \url{https://github.com/OpenAssets/open-assets-protocol/blob/master/specification.mediawiki}},
Coinspark\footnote{\url{http://coinspark.org/}} и
Colu\footnote{\url{https://www.colu.com/}}. Существуют виртуальные
кошельки, поддерживающие несколько стандартов
одновременно\footnote{ChromaWallet поддерживает OAP и OPOBC
  \url{http://chromawallet.com/}}. Стоит отметить, что все
перечисленные стандарты используют метаданные транзакций в биткоине
для передачи информации о цвете, а не изменяют протокол напрямую (что
привело бы к форку). Тем не менее, поддержка стандарта с изменением
протокола может быть сделана проще и эффективнее.

С интеграцией цветных монет связано несколько дополнительных
задач. Во-первых, изменяется логика валидации транзакции. Если раньше
достаточным условием было проверить, что сумма выходов не превосходит
сумму входов, то с цветными монетами существует несколько
подходов. Первый предлагает запрет на транзакции, ``красящие'' монеты
-- то есть изменяющие цвет в транзакции. В этом случае валидация
транзакции сводится к валидации сужений транзакций до каждого
цвета. Этот подход реализован во всех упомянутых
стандартах. Во-вторых, изменяется логика эмиссии ресурсов. OAP
предоставляет возможность производить эмиссию активов, удостоверяя
эмитента отдельным секретным ключом. Вместо возможности производить
чистую эмиссию можно предложить решение с покраской монет --
транзакция может менять тег средств, если она удовлетворяет правилам
покраски. Этот подход был применен при имплементации цветных монет в
RSCoin\footnote{Репозиторий RSCoin на github:
  \url{https://github.com/input-output-hk/rscoin-haskell}}: монеты
цвета $0$ могли быть покрашены в цвет $i \neq 0$ (единственное правило
перекраски). EPOBC решает проблему похожим образом, разрешая перевод
базовых монет (монет базовой криптовалюты) в любой другой цвет.

\section{Иерархический детерминированный кошелек}

Дополнение к протоколу биткоина под названием HD кошелек (Hierarchical
Deterministic Wallets) было предложено в рамках
BIP32\footnote{\url{https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki}}
и предлагает расширение схемы подписей
secp256k\footnote{\url{http://www.secg.org/sec2-v2.pdf}}, решающее
проблему дублирования секретных ключей на разных устройствах.

Пара ключей $Pk$ и $Sk$ (стандарт secp256k1) расширяются 32 байтами
энтропии $c$, которая называется кодом цепи (chain code), результируя
в пару расширенных ключей $Pke = (Pk, c)$ и $Ske = (Sk, c)$ по 64 байт
каждый. Затем вводятся две ключевые функции:

\begin{enumerate}
\item $CKDpriv : (Ske, i) \rightarrow Ske$. Принимает на вход расширенный
  секретный ключ $Ske$, целое число $i$ в интервале $[0..2^{32})$ и
  возвращает расширенный секретный ключ.
\item $CKDpub : (Pke, i) \rightarrow Maybe Pke$. Если $i \geq 2^{31}$, функция
  возвращает $Nothing$. Это расширение называется харденингом
  (hardening), запрещая выводить половину интервала публичных дочерних
  ключей. Если $i < 2^{31}$, возвращает расширенный публичный ключ.
\end{enumerate}

Функции $CKDpriv$ и $CKDpub$ построены таким образом, что каждая
расширенная пара $\langle Ske,Pke \rangle$, полученная с их помощью для
одного $i$, является валидной парой секретный-публичный
ключ. Возможность выводить ключи в любом другом направлении
(родительские из дочерних, секретные из публичных) отсутствует.

Стандарт реализован в Cardano SL/Ouroboros и является основным. Кроме
этого, Cardano SL поддерживает обычные ключи secp256k1 и
скрипт-адреса.

\chapter{Описание алгоритма}

\section{Интеграция цветных монет}

Поскольку данная работа предлагает изменение протокола Ouroboros без
поддержки обратной совместимости, поддержка цветных монет существенно
упрощается, поскольку не требует надстраивания (например, через
метаданные транзакции). Эта секция описывает различные нюансы и детали
реализации.

Первая необходимая модификация это изменение структуры данных
монеты. Добавим тег цвета типа $Int32$ к каждой монете. Монеты цвета
$basec$ считаются базовыми монетами. Тег в бинарном (сериализованное)
представлении монеты может опущен, в этом случае предполагается, что
тег равен $basec$. Также добавим два других типа монет -- $ratec$ и
$\tau c$. $Ratec$ монеты будут использоваться для представления
пользовательского рейтинга в системе, а $\tau c$ будут представлять
очки времени. Четвертая группа монет -- это монеты действия
$actc_i$. Размер этого множество можно, для простоты, взять
дополнением всего пространства цветов за вычетом упомянутых ранее, то
есть $N_a = 2^{32}-3$. ОБозначим множество $actc = \{actc_i\}_{i=1..N_a}$.

Воспользуемся схемой покраски монет, не прибегая к возможности эмиссии
активов нового цвета. Все монеты конвертируются один к
одному. Предполагается, что реальная стоимость одной монеты
пренебрежима (единица монеты в биткоине сатоши стоит 0.00001
USD). Построим ориентированный граф конвертации цветов монет $G$, где
вершины представляют собой типы монет, а ребро $uv$ принадлежит графу,
если возможна конвертация монеты типа $u$ в тип $v$. Используемый граф
конвертации будет иметь следующую форму:
\begin{align*}
  TG = \langle &\{basec, ratec, \tau c\} \cup actc,\\
  &\{basec \rightarrow ratec
  , basec \rightarrow \tau c\} \cup
  \{\tau c \rightarrow actc_i\}_{i=1..N_a} \cup
  \{actc_i \rightarrow \tau c\}_{i=1..N_a}\rangle
\end{align*}

Таким образом, он включает в себя два односторонних правила
преобразования и одно двухстороннее для каждой пары $\langle \tau c,
actc_i\rangle$.

Правило валидации транзакции должно определить, может ли выделенный
сет входов быть покрашен в цвета выхода в соответствии с $G$. Легко
заметить, что некоторые формы графов позволяют проводить линейную по
числу входов и выходов валидацию: представим граф $\{A \rightarrow B,
C \rightarrow D, E \rightarrow F, \cdots\}$ -- его валидация сводится
к валидации сужений транзакции на пары цветов.

TODO тут должен быть алгоритм валидации транзакции на абстрактном графе.

Что касается гарантий стабильности протокола Ouroboros, предлагается
поддерживать только $basec$ во всех частях алгоритма, связанных с
размером сбережений (SSC/выбор лидеров, делегация и различные пороги,
система поощрений). Легко видеть, что эта модификация не затрагивает
гарантий базового протокола:
\begin{enumerate}
\item Не существует возможности получить $basec$ монеты из любого
  другого цвета
\item Общая потеря $basec$ монет при конвертации не меняет поведения,
  потому что базовая реализация позволяет уничтожать монеты, выставляя
  ненулевую разницу между входами и выходами транзакции. Также, не
  запрещено отправлять средства на адреса с неизвестным секретным
  ключом, что эквивалентно уничтожению средств.
\end{enumerate}

\section{Система контрактов}

Контракт -- формализация способа взаимодействия пользователей как
множества обязательств, нужд и правил, а также соответствия этим
обязательствам в виде рейтинга. Главная цель этой секции состоит в
описании обязательств таким образом, чтобы, имея данные о том, какие
относящиеся к контракту действия были выполнены (и в какой мере),
пользователям можно было бы проставить соответствующий рейтинг. Этот
рейтинг должен коррелировать с усилиями пользователей в отношении
правил контракта и мотивировать участников выполнять свои
обязательства.

\subsection{Ответственности и нужды}

Представим условие контракта в виде набора обязанностей. Обязанность в
общем виде описывается следующими параметрами:

\begin{enumerate}
\item Тип деятельности: любая активность, имеющая начало и
  конец. Например, парное программирование или какой-либо вид спорта.
\item Временное ограничение: как часто и как долго деятельность должна
  иметь место. Некоторые типы деятельностей очевидным образом не
  входят в это описание из-за их случайной природы (например, условная
  деятельность ``прогулка в парке, если не идет дождь''). Тем не
  менее, ограничение по времени покрывает большую долю необходимых
  ситуаций.
\item Получатель: тот, кто определяет необходимость в совместном
  времяпровождении. Получатель -- пользователь, вместе с которым эта
  активность должна происходить. Групповые деятельности, в которых
  получателем является каждый участник, описываются множеством
  обязанностей (по одной на удовлетворения потребностей каждого). Для
  активностей без явного получателя это поле может быть
  опущено. Пример: ученик должен тратить минимум 30 часов еженедельно
  на домашние задания, тем не менее это требование родителей.
\item Поставщики: пользователи, ответственные за то, чтобы
  обязательство было выполнено. В случае невыполнения требований,
  теряют свой рейтинг. Описываются в дизъюнктивной нормальной форме
  без отрицания -- такое представление одновременно предоставляет
  необходимую гибкость и значительно упрощает валидацию при подсчете
  рейтинга.
\end{enumerate}

Формальное описание обязанности (TODO сделать красивее):

\begin{align*}
Maybe \ a &= Just \ a \ | \ Nothing \\
Andterm \ a &= a \ | \ (Andterm \ a) \wedge (Andterm \ a) \\
Term \ a &= Andterm \ a \ | \ (Term \ a) \vee (Term \ a) \\
Suppliers &= Term \ UserId\\
Receiver &= UserId\\
Timeframe &= \langle Hours, Maybe \ Times \rangle\\
Responsibility &= \langle Suppliers, Maybe \ Receiver, ActivityType, Timeframe \rangle
\end{align*}

Частым случаем является набор ответственностей, имеющих одно множество
``поставищики и получатель''. Пусть дано множество обязанностей
$R_1$. Рассмотрим $R_2 \subset R_1$, такое что для каждой обязанности
$r \in R_2$ если $r$ имеет форму $S_1\&S_2\&…\&S_n \rightarrow Receiver$. Построим ориентированный граф $G$, создав по вершине на
каждого пользователя, являющегося поставщиком или получателем в хотя
бы одной $r \in R_2$ и по ребру на $\forall r \in R_2 \langle S_i,
Receiver \rangle$ . Преобразуем $G$ в $F$: оставим вершины, но добавим
$uv$ в $F$ только если $uv \in G \wedge vu \in G$. Заметим, что если в
$R_2$ был набор пользователей $U = \{U_i\}_{i=1..N}$ и набор
обязанностей $\{U \setminus U_i \rightarrow U_i\}_{i=1..M}$ с
одним и тем же временным ограничением и типом активности, то $F$
содержит клику на множестве ребер $U$. Эти рассуждения могут быть
применены для эффективного кодирования (сериализации) набора
обязанностей.

Такое описание обязанности является достаточно широким, чтобы
покрывать большинство необходимых ситуаций и в то же время простым,
что позволяет автоматизировать процесс выставления рейтинга.

\subsection{Скрипт контракта}

All information we need to simplate a contract can be packed into the
script.

The scheme is used as following. First, users obtain certain amount of
basec coins from seller. This coin type is distributed freely as money
equivalent -- it’s supposed you can buy it from other users in
network, it’s held by people that support the network (run clients)
and it’s proportional to the whole network support effort
(electricity, hdd space, etc). Then users initiate their contract by
creating the certain declaration datatype (config) that contains
metainfo about it Money is sent to contract public address (hash of
this config datatype).

Except for the config (hardcoded into validator), contract has an
internal mutable state. For instance, we should store the last time
contract was triggered. We can hardcode all mutable variables into
contract and just re-create it every time mutable state is changed,
but it’s expensive (in terms of blockchain) and makes things more
complex (hard to track single contract transactions over several
contract periods). Instead it’s suggested to use the following
solution. First, we’ll hardcode $eiStart$ into contract that would
represent the epoch contract starts at. User doesn’t have any
incentive to put irrelevant value inside -- too old values would
prevent contract from retriggering, values far into future make
contract unusable as well. Then we’ll create a function inside
contract that retrieves the last renewal transaction epoch or
$eiStart$ if there are no renewal transactions yet. Let’s bind this
value to $eiLast$. When renewing, validator will retrieve transactions
from $[eiLast...eiLast+contractPeriod]$ range using primitive
$getLastEi$ that will be added to the scripting language (that will
use node’s resources). Introducing primitives approach can be taken
when getting transactions for the certain period. It is suggested to
add extra $searchTxs$ primitive that will retrieve “related”
transactions from node’s blockchain given the certain predicate (in
our case: lying in the time range, related to the contract).

So when contract period is over, it should be “renewed” -- we need to
calculate users ratings and switch contract to the next epoch. This
renewal is triggered user side by collecting related tx data (note
that clients still don’t need to hold the whole blockchain but only
related transactions), running the script and sending its
validator/redeemer parts along with transaction to the
network. Redeemer script is simple: it contains only signatures in
fact. Transaction itself contains script address as input (coins of
type basec), selected block owner from the last $k$ blocks that will
receive paying money and user ratings (ratec type). validator should
check that transaction input fee corresponds to the contract constant
period fee, that inputs/outputs match and that ratings are assigned
accordingly to action transactions executed in the last period (and
strategy of rating assignment). We are also introducing changes to
coin coloring and validation. It’s allowed to automatically “color” or
“exchange” paying coins to rating coins using fixed rate that is the
current protocol constant (ouroroboros update system/constants). It’s
also forbidden to do it in any other than contract renewal transaction
so people can’t easily produce action coins (more on this later…
TODO).

Rating assignment policy What we want to do is to agree on some rating
value (which is special coin type/color) that will represent person’s
commitment to the contract and so is proportional to the effort. It is
suggested to scale it to $[0,contractPeriod]$ where period is expressed
in number of slots, so amount of rating coins for the single contract
renewal correlates with the contract time.

Assignment policy requirements are:

\begin{enumerate}

\item If person doesn’t take part in any contract-related activity,
  his rating for the contract period is zero.

\item For completely fullfilled group responsibility (term contains
  “and” links only) user (supplier) gets $1$.

\item For non-fullfilled group responsibility all suppliers have their
  rating decreased.

\item For non-group responsibility (or-cases) every user that enters
  at least one disjunctive case, splits responsibility with others,
  evenly.

\end{enumerate}

Now what’s left is to define how exactly this formulas are operated. For every responsibility define:

\begin{align*}
hoursLoss &= 1 - min(\frac{spentHours}{totalHours}, 1) \\
timesLoss &= if totalTimes = Nothing \\
          &  then hoursToss \\
          &  else 1 - min(\frac{spentTime}{totalTimes}, 1) \\
totalLoss &= \frac{hoursLoss + totalLoss}{2}
\end{align*}

The total loss is amount of percent that’s lost to contribute to this
responsibility. Split it among users using requirements above (every
user either gets full loss or $\frac{1}{len(users)}$ of it). Then for every
contract multiply it on contract’s timeframe, sum everything up and
scale it to amount of minutes (hours? Days? roughly…) in the
contract. We’ll get a loss for every user.

The functionality that calculates the ratings based on
responsibilities, transactions and other contract parameters is called
RateAssign.

$$
RateAssign = undefined -- TODO
$$

\section{Proof of activity transaction}

This section will describe how to build time tracking transaction or
proof of activity.

Transaction represents an act of single activity type spend by a set
of users simultaneously. Let $Users = \{U_i\}_{i=1..N}$ stay for the
set of users taking part in the activity and $Spent_i = <tauS_i,
\Delta_i>$ for the time spent by user $U_i$ -- tuple of start time
(global time) and duration in seconds. $ActivityType(k)$ = $actc_k$ is
a coin type representing some activity. Then we define
pre-transaction: $TxActionPre = <Users, \{Spent_i\}_{i=1..N},
ActivityType(k)>$. This real-world model satisfies the requirements we
have in respect to contract -- it captures the basic notice of users
group, activity type and time intervals. Though as real basecoin
transactions appear in blocks that have a dedicated timeframe
themselves (because issued in the fixed slot), we don’t need to put a
timestamps into it. Moreover, this representation adds more complexity
due to the fact we still need to derive how much time each pair of
users spent together, as $Spent_i$ intervals don’t have to be equal
for every user.

To build a real proof of activity transaction $TxAction$ we will need
to transform the $TxActionPre$ into the set of spending inputs and
outputs. Let $UPk_i$ stay for the public key of user participating in
the contract, which is embedded into the contract. We define a mapping
function $CActOut(C, {Uij}) : Pk$, that given a contract and a
non-empty subset of users participating in this contract, returns a
public key of an action spending address. $CActOut$ is injective and
has a finite range of size $2^n = \sum{\binom{n}{i}}$ for the chosen
contract. We use $CActOut$ to associate the contract with the
temporary action balances that will be used later by the contract
script to collect tracking information. Let $ESet = \{Ev_i\}_{i=1..k}$
be the set populated by every interval start or end event from
$TxActionPre$ $Spent_i$ set. Form the interval set $ISet =
\{IEv_i\}_{i=1..k-1}$ from the events set. It’s easy to see that in
every interval from this set there is a particular set of users
active. Then for every user $U_i$ and his $Spend_i$ we divide the
$Delta_i$ into chunks accordingly to the $ESet$. We form the
compliance set $Compl_i$ from $Delta_{i,j}$ by first transforming
every user set that acts in the $Delta_{i,j}$ to the correspondent
address $CActP_k$ (using $CActOut$) and then merging the
$\{<Delta_{i,j}, CActP_{k,j}>\}$ that have the same public key,
summing up the deltas -- so we don’t have duplicate outputs. Then we
transform every $Delta_{i,s}$ into $DTau_{i,k}$ by converting the
time interval to minutes. We end up with $Compl_i$ containing
$\{<DTau_{i,s}, CActP_{k,s}>\}$ -- the set of time intervals $U_i$
spends on every group of users he interacted with through the
$TxActionPre$, with time intervals corresponding to interaction
length.

This procedure is done for every user. ${Compl_i}$ can be then
transformed into the real transaction. Each user defines
$\sum(DTau_{i,s})$ $tauc$ as input and sets his outputs to
$\{CActP_{k,s}\}$ with $DTau_{i,s}$ correlating with amount of color
coins of color $actc_i$ for some $i$ chosen before. This user chunks
can be trivially merged into the single transaction. So in the end the
transaction $TxAction$ contains the inputs $<UPk_i, UTau_i, tauc>$ and
outputs $<CActP_k, actc_j>$.

The transaction validity is obvious by construction, as the coins
spent by every user are matching the sum property (inputs are defined
as sum of outputs) and tx conforms to coloring rules -- it transforms
$tauc$ into $actc_j$. The way of transforming $TxActionPre$ to the
$TxAction$ also satisfies the main property: we save all the crucial
information about the commitments while removing UTC timestamps
completely.

\section{Action balances functionality}

The $CActOut(C, U)$ function needs to derive a set of public keys from
the contract and at the same time give private components of these
keys to users. This is crucial because otherwise action coins sent to
action balances can’t be reused and it leads to useless blockchain
bloat. The solution to this problem is the following. We assign a HD
wallet spec root private key $CSke$ to one of contract users, which we
will call contract master. This private key must be
unhardened. Contract master doesn’t share $CSke$ with anybody
else. The public component $CPke$ of the root key is hardcoded into
the contract as a separate field. Now we can instantiate the function
$CActOut(C,U)$ as following:

\begin{enumerate}

\item Enumerate all choices of user subsets using using $userEnum : U
  -> \frac{N}{2^n}$. The $userEnum$ function can be defined trivially. One
  example is the following. Represent every user with a $i \in
  \mathbb{N}$. Convert every set $U_i$ to the list of users converted to their
  indices, sorted. Lexicographical order on these strings will define
  the order on subsets.

\item $CActOut(C,U_i) = CPke/userEnum(U)$. Recall that notation
  $Pke/i$ defines the $i$th public key derived from $Pke$.
\end{enumerate}

\section{Contract renewal transaction and assets flow}

The only way contract executes the rating assignment is via the
renewal transaction. Renewal transaction consists of two parts:

\begin{enumerate}
\item The action coins $ActPeriod$ accumulated on $CActOut(C,U)$ for
  every user subset $U$. These tx inputs should be from blocks that
  are inside the last contract’s period. These coins are converted
  back to timec and can be reused later.
\item Renewal fee in basec. This gets converted to reward coins
  mostly, which are distributed over contract reward addresses
  ${CRewP_k}$. These are also used to pay the transaction fee.
\end{enumerate}

Renewal addresses are special public keys that can be derived from the
contract and user’s public key. They don’t have the matching private
key by design, so users rating coins can never be transferred back
(and spoil the statistics). It is suggested to derive $CRewP_k$ as
$Blake2b512(CPk || UPk_i)$, where $Blake2b512$ is a blake2b hashing
function (\url{https://blake2.net/blake2.pdf}) with output of size
$512$ bits, to match the HD wallets signing scheme.

The renewal transaction can spend money from contract’s account only
if it conforms to a rules of reward distribution, general transaction
form, users output. All of this functionality is embedded into the
validator script. More specific description will be presented later.

Money flow and contract usage process is the following.

\begin{enumerate}
\item A group of users create a contract script, pasting the custom
  values into the contract script template. Initial values also
  include the $eiStart$ variable that is a slot representing contract
  starting point.
\item Any user initiates the contract by sending basec on the script
  address. This allows later to make a renewal transaction.
\item Users spend time tracking their activities in the contract
  period interval.
\item After the contract period is over, contract master uses his
  client to calculate the rewards for the period thus forming the
  renewal transaction. He also supplies the signatures for action
  balances public keys (using his $CSke$) and empty redeeming script.
\item User propagates the transaction over the network.
\item Node check that transaction conforms to coloring and balances
  rules first. Then it verifies all the $CActPk_i$ signatures from
  user and launches the validator script.
\item Validator script has an access to the blockchain and current
  transaction. It retrieves the last epoch index where renewal
  transaction took place (by searching transactions from its public
  address using $getLastEi$ primitive) or sets this to hardcoded start
  epoch. It runs the same procedure user did on the client part and
  ensures that:
  \begin{enumerate}
  \item Renewal transaction matches an overall template: inputs are
    action addresses and contract pk, outputs are rating addresses and
    there is an address for transferring tauc back.
  \item Action utxo spent by the transaction matches the one
    calculated inside the script. Script calls the needed primitives
    to get all utxo that was accumulated during the script period on
    action addresses. This is trivial to integrate into the scripting
    language standard library (prelude).
  \item Reward is distributed correctly. Script runs the functionality
    $RateAssign$ to determine rate outputs. Script fails if
    transaction rate outputs don’t match expected ones.
  \end{enumerate}
\item Renewal transaction gets into the blockchain, users have their
  new ratings on rate accounts. Once renewal transaction is in the
  blockchain, users can continue from step (3). Transaction can be
  rejected if contract doesn’t have enough basec to be renewed (then
  someone should pay for the renewal) or if master forms incorrect
  transaction.
\end{enumerate}

\section{Pre-tx formation layer}

In order for users to create tracking transactions they must collect
multiple signatures. The standard approach for this is to either share
signatures in text or qr codes (electrum) or use a centralized
transaction pool (coinkite). Network-based approaches can be
abstracted to two separate classes by their functionality: transport
and interface. Formation transport defines where and how raw
information (unsigned transactions) is stored. Interface layer defines
API to access this information. We start this part from API
description, defining minimal amount of functionality needed to be
supported. Next subsection will give overview on what solutions can be
applied to implement the transport layer.

\subsection{API layer and requirements}

The main idea of pre-tx formation layer in general is to provide users
a possibility to create a transaction in the “track in -- track out”
fashion how it is done in org-mode. We will refer to the software user
uses as “client” software, while the entity that remotely holds the
common users data will be called a transport.

It is also appropriate to divide API into two parts: pre-tx formation
and signature collection.

Pre-tx API should be able to do the following things:

\begin{enumerate}
\item $StartActivity(args) : txid$ call initiates the empty
  pre-transaction. User who calls must attach his public key and sign
  the request with this public key. User should also specify the
  security scope: contract id or users that can take part in this
  activity directly.
\item $SearchActivity(args) : txid$ is a call that searches the
  activity by participants (or txid directly) taking action in it. If
  the corresponding pre-tx is ready, it returns the transformed. If
  the data is not ready yet (not everybody clocked out), it returns
  all the data currently known.
\item $JoinActivity(txid) : Bool$ allows contract participant to add his
  $startTime$ timestamp to the activity.
\item $AnnounceExit(txid) : Maybe PreTx$ cuts the tracking interval
  for the user for the given transaction id. If the user was last to
  exit the activity, the call returns $Just PreTx$, $Nothing$ otherwise.
\end{enumerate}

The service also removes all the information that stays too long in
the transport. Completed pre-transactions are removed $t1$ minutes
after they are formed, maximum duration of pre-tx formation $t2$ is
different and much more ($~12$ hours should be enough i suppose).

Signature collection API is something yet to describe TODO. But in
general it has $<commit, retrieve, sign>$ scheme.

\subsection{Transport layer}

WIP. Centralized service implementation is straight-forward because
it’s under your control and it’s trusted. Just make a simple http
server (servant + acid-state). Distributed service built on to of
nodes is more tricky, because we need to protect from sybil
attacks. Some ideas:

\begin{enumerate}
\item DHT based on CSL stake with a low threshold to prevent random
  users come. Pretty good idea in fact.
\item http://www.cypherpunks.ca/~iang/pubs/robustMessagePassing.pdf Or
  something like that. Read BFT tolerant DHT.
\end{enumerate}

\chapterconclusion

В конце каждой главы желательно делать выводы. Вывод по данной
главе~--- ну чето написал, каеф.


%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

Алгоритм хороший и примеры интересные.

\printmainbibliography




\end{document}
